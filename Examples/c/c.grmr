export: c
root:
	external_declaration+
token:
    keyword | identifier | constant | string_literal | punctuator | whitespace // whitespace is added to remove comments. It is skipped anyway

punctuator: '...', '<<=', '>>=', '->', '++', '--', '&=', '##', '*=', '+=', 
    '-=', '/=', '%=', '<=', '>=', '>>', '==', '!=', '^=', '||', '&&', '|=', 
    '<<', ';', '=', '*', '/', '%', '+' , '-', '>', '&', '^', '|', ',', '#', 
    '<', '[', ']', '(', ')', '{', '}', '.', '~', '!', '?', ':'

keyword:
    'auto', 
    'break', 
    'case', 
    'char', 
    'const',
    'continue', 
    'default', 
    'do', 
    'double', 
    'else', 
    'enum', 
    'extern', 
    'float', 
    'for', 
    'goto', 
    'if', 
    'inline', 
    'int', 
    'long', 
	'macro',
    'register', 
    'restrict', 
    'return', 
    'short', 
    'signed', 
    'sizeof', 
    'static', 
    'struct', 
    'switch', 
    'typedef',
    'union', 
    'unsigned', 
    'void', 
    'volatile', 
    'while', 
    '_Alignas',
    '_Alignof',
    '_Atomic', 
    '_Bool',
    '_Complex', 
    '_Generic', 
    '_Imaginary', 
    '_Noreturn', 
    '_Static_assert',
    '_Thread_local'

whitespace(cxpeggen.skip_token):
    "(\s+|(\\\\\n)|//[^\n]*\n|/\*.*\*/)+" // includes comments and line-continuation

identifier:
    "[a-zA-Z_]\w*"

digit:
    "\d"

nondigit:
    "[a-zA-Z_]"

// includes octal and hex integer constants
int_constant:
    "(([1-9]\d*)|(0(x|X)[A-Fa-f0-9]+)|(0[0-7]*))(((u|U)(l|L)?)|((l|L|LL|ll)(u|U)?))?"

hex_float_constant:
    "0(x|X)((([A-Fa-f0-9]*\.[A-Fa-f0-9]+)|([A-Fa-f0-9]+\.))|([A-Fa-f0-9]+))p(\+|-)?\d+(f|l|F|L)?"

decimal_float_constant:
    "((((\d*\.\d+)|(\d+\.))([eE][-+]?\d+)?)|(\d+[eE][-+]?\d+))(f|l|F|L)?"

float_constant:
    decimal_float_constant | hex_float_constant

enum_constant(cxpeggen.check_enum):
    identifier

char_constant:
    "[LuU]?'([^\\\\]*?(\\\\.)?)*?'"

constant:
    int_constant | float_constant | enum_constant | char_constant

// check to make sure the inner double quotes work
string_literal:
    "(u8|u|U|L)?\"(((?<=\\\\)\")|[^\"])*\"" //"(u8|u|U|L)?\"([^\\\\]*?(\\\\.)?)*?\""  // better one from my json grammar might be "(u8|u|U|L)?\"(((?<=\\\\)\")|[^\"])*\"" // this is literally everything between two double quotes including escaped double quotes

// below are for parsing

primary_expression:
	  identifier
	| constant
	| string_literal
	| '(', expression, ')'
	| generic_selection

generic_selection:
	'_Generic', '(', assignment_expression, ',', generic_assoc_list, ')'

generic_assoc_list:
	','.generic_association

generic_association:
	(type_name | 'default'), ':', assignment_expression

// fix left recursion
postfix_expression:
	postfix_expression_start, ( get_member_expression
                              | call_expression
                              | namespace_access_expression
                              | pointer_access_expression
                              | '++'
                              | '--'
                              )*

postfix_expression_start:
    primary_expression | compound_literal
	
compound_literal:
	'(', type_name, ')', '{', initializer_list, ','?, '}'

// arrays, [] operator overloading, and templates
get_member_expression:
	'[', expression, ']'

call_expression:
	'(', argument_expression_list?, ')'

argument_expression_list:
	','.assignment_expression
	
namespace_access_expression:
	'.', identifier // namespace, struct, or union member access
	
pointer_access_expression:
	'->', identifier	// struct or union pointer member access

// unary_expression is a good test of PEG operator precedence
unary_expression:
	  postfix_expression
	| '++', unary_expression
	| '--', unary_expression
	| unary_operator, cast_expression
	| 'sizeof', unary_expression // recursive
	| 'sizeof', '(', type_name, ')'
	| '_Alignof', '(', type_name, ')'
	// typeof is in gcc only

unary_operator:
	  '&'
	| '*'
	| '+'
	| '-'
	| '~'
	| '!'
	
cast_expression:
	('(', type_name, ')')*, unary_expression

multiplicative_expression:
	cast_expression, (('*' | '/' | '%'), cast_expression)*

additive_expression:
	multiplicative_expression, (('+' | '-'), multiplicative_expression)*

shift_expression:
	additive_expression, (('<<' | '>>'), additive_expression)*
	
relational_expression:
	shift_expression, (('<' | '>' | '<=' | '>='), shift_expression)*
	
equality_expression:
	relational_expression, (('==' | '!='), relational_expression)*
	
AND_expression:
	equality_expression, ('&', equality_expression)*
	
XOR_expression:
	AND_expression, ('^', AND_expression)*
	
OR_expression:
	XOR_expression, ('|', XOR_expression)*

logAND_expression:
	OR_expression, ('&&', OR_expression)*

logOR_expression:
	logAND_expression, ('||', logAND_expression)*
	
conditional_expression:
	logOR_expression, ('?', expression, ':', logOR_expression)*

assignment_expression:
	(unary_expression, assignment_operator)*, conditional_expression

assignment_operator:
	  '='
	| '*='
	| '/='
	| '%='
	| '+='
	| '-='
	| '<<='
	| '>>='
	| '&='
	| '^='
	| '|='

expression:
	','.assignment_expression
	
constant_expression:
	conditional_expression





// DECLARATIONS

declaration:
	  declaration_specifiers, init_declarator_list?, ';'
	| static_assert_declaration

declaration_specifiers:
	( storage_class_specifier
	| type_specifier
	| type_qualifier
	| function_specifier
	| alignment_specifier)+

init_declarator:
	declarator, ('=', initializer)?
	
init_declarator_list:
	','.init_declarator

storage_class_specifier:
	  'auto' // C11
	| 'extern'
	| 'register'
	| 'static'
	| '_Thread_local'
	| 'typedef'
	
type_specifier:
	  'void'
	| 'char'
	| 'short'
	| 'int'
	| 'long'
	| 'float'
	| 'double'
	| 'signed'
	| 'unsigned'
	| '_Bool'
	| '_Complex'
	| atomic_type_specifier
	| struct_or_union_specifier
	| enum_specifier
	| typedef_name
	
struct_or_union_specifier:
	struct_or_union, ((identifier?, '{', struct_declaration+, '}') | identifier)

struct_or_union:
	'struct' | 'union'

// struct_declaration_list does not need to exist

struct_declaration:
	  specifier_qualifier_list, struct_declarator_list?, ';'
	| static_assert_declaration

specifier_qualifier_list:
	(type_specifier | type_qualifier)+ // add restrict so that 'const' is left-associative, which ensures appropriate interpretation

struct_declarator_list:
	','.struct_declarator

struct_declarator:
	  declarator
	| declarator?, ':', constant_expression

enum_specifier:
	'enum', ((identifier?, '{', enumerator_list, ','?, '}') | identifier)

enumerator_list:
	','.enumerator

enumerator:
	enum_constant, ('=', constant_expression)?

atomic_type_specifier:
	'_Atomic', '(', type_name, ')'

type_qualifier:
	  'const'
	| 'volatile'
	| 'restrict'
	| '_Atomic'
	
function_specifier:
	'inline' | '_Noreturn'
	
alignment_specifier:
	'_Alignas', '(', (type_name | constant_expression), ')'

declarator:
	pointer?, direct_declarator // forward declare direct_declarator

direct_declarator: 
	(identifier | '(', declarator, ')'), (array_declarator | function_declarator)*

array_declarator:
	'[', 'static'?, type_qualifier_list?, 'static'?, (assignment_expression | '*')?, ']' // static and assignment_expression cannot be together

function_declarator:
	'(', (parameter_type_list | identifier_list)?, ')' // consider excluding the identifier_list

pointer:
	('*', type_qualifier*)+

parameter_type_list:
	parameter_list, (',', '...')?

parameter_list:
	','.parameter_declaration

parameter_declaration:
	declaration_specifiers, (declarator | abstract_declarator)? // need to forward declare declarator and abstract declarator	

identifier_list:
	','.identifier
	
type_name:
	specifier_qualifier_list, abstract_declarator? // forward declare abstract declarator
	
abstract_declarator:
	  pointer
	| pointer?, direct_abstract_declarator // forward declare direct_abstract_declarator
	
direct_abstract_declarator:
	  '(', abstract_declarator, ')'
	| ('(', abstract_declarator, ')')?, (array_abs_declarator | function_abs_declarator)+

array_abs_declarator:
	'[', (('static'?, type_qualifier_list?, 'static'?, assignment_expression?) | '*'), ']' // static and assignment_expression cannot be together

function_abs_declarator:
	'(', parameter_type_list?, ')'
	
typedef_name(cxpeggen.check_typedef_name):
	identifier
	
initializer:
	assignment_expression | '{', initializer_list, ','?, '}'

initializer_list:
	','.(designation?, initializer)

designation:
	designator+, '='

designator:
	  '[', constant_expression, ']'
	| '.', identifier
	
static_assert_declaration:
	'_Static_assert', '(', constant_expression, ',', string_literal, ')', ';'





	
// STATEMENTS

statement:
	  labeled_statement
	| compound_statement
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement

labeled_statement:
	(identifier | ('case', constant_expression) | 'default'), ':', statement

compound_statement:
	'{', block_item*, '}'
	
//block_item_list:
//	block_item+
	
block_item:
	declaration	| statement
	
expression_statement:
	expression?, ';'
	
selection_statement:
	  'if', '(', expression, ')', statement, ('else', statement)?
	| 'switch', '(', expression, ')', statement
	
iteration_statement:
	  'while', '(', expression, ')', statement
	| 'do', statement, 'while', '(', expression, ')', ';'
	| 'for', '(', (expression?, ';' | declaration), expression?, ';', expression?, ')', statement

jump_statement:
	(('goto', identifier) | 'continue' | 'break' | ('return', expression?)), ';'

// REMOVE declaration_list? for old-style K&R
function_definition:
	declaration_specifiers, declarator, declaration_list*, compound_statement
	
external_declaration:
	  function_definition
	| declaration

