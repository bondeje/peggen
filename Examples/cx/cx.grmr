/*

This module should get built by a cfg file with json format

grammar for config file: 
    - syntax follows PEP-617 for Python, but does not implement their left-recursion methods
    - there is additionally the '/' operator which is choice operator but selects largest (in terms of tokens) results

ProductionName[attributes](transform function taking a parser and result ASTNode and returning an ASTNode):
    sequence of PEG parser rules (ignoring whitespace)

[attributes] - this is reserved syntax for special handling of certain productions

For each ProductionName:
    create an appropriate function

Productions with only terminals...an attempt will be made to make it a single regex

2 productions are special:
    - punctuators and keywords. These must all be string literals and a separate rule will be made for each. For the case of keywords, the rule will be CX_[keyword in upper case]. For the case of punctuators, the rules are converted to alphanumeric identifiers that can be retrieved with cx_get_punctuator_enum(char * punctuator)

*/

export: cx
root:
	external_declaration+
token:
    keyword | identifier | constant | string_literal | punctuator | whitespace // whitespace is added to remove comments. It is skipped anyway

punctuator: '...', '<<=', '>>=', '->', '++', '--', '&=', '##', '*=', '+=', 
    '-=', '/=', '%=', '<=', '>=', '>>', '==', '!=', '^=', '||', '&&', '|=', 
    '<<', ';', '=', '*', '/', '%', '+' , '-', '>', '&', '^', '|', ',', '#', 
    '<', '[', ']', '(', ')', '{', '}', '.', '~', '!', '?', ':'

keyword:
    'alignas', /* C23 (macro pre-C23) */
    'alignof', /* C23 (macro pre-C23) */
    'as', /* new for imports of cx modules */
    'auto', 
    'bool', /* C23 */
    'break', 
    'callable', 
    'case', 
    'char', 
    'constexpr', /* C23 */
    'const',
    'continue', 
    'default', 
    'do', 
    'double', 
    'else', 
    'enum', 
    'extern', 
    'false', /* C23 */ 
    'float', 
    'for', 
    'goto', 
    'if', 
    'import', /* new for imports of cx modules */ 
    'inline', 
    'int', 
    'long', 
	'macro',
    'nullptr',  /* C23 */
    'register', 
    'restrict', 
    'return', 
    'short', 
    'signed', 
    'sizeof', 
    'static_assert', /* C23 */ 
    'static', 
    'struct', 
    'super',  /* new */
    'switch', 
    'thread_local', /* C23 */ 
    'true', /* C23 */ 
    'typeof_unqual',  /* C23 */
    'typeof', /* guaranteed even before C23 or non-GCC, but limited those that can be resolved by this transpiler */ 
    'typedef',
    'union', 
    'unsigned', 
    'virtual', /* reserved for use in diamond problem resolution only */
    'void', 
    'volatile', 
    'while', 
    '_Alignas', /* pre-C23 */
    '_Alignof', /* pre-C23 */
    '_Atomic', 
    '_BitInt', /* C23 */
    '_Bool', /* pre-C23 */ 
    '_Complex', 
    '_Decimal128', /* C23 */
    '_Decimal32', /* C23 */ 
    '_Decimal64', /* C23 */ 
    '_Generic', 
    '_Imaginary', 
    '_Noreturn', 
    '_Static_assert', /* pre-C23 */ 
    '_Thread_local' /* pre-C23 */

whitespace(cxpeggen.skip_token):
    "(\s+|(\\\\\n)|//[^\n]*\n|/\*.*\*/)+" // includes comments and line-continuation

identifier:
    "[a-zA-Z_]\w*"

digit:
    "\d"

nondigit:
    "[a-zA-Z_]"

// includes octal and hex integer constants
int_constant:
    "(([1-9]\d*)|(0(x|X)[A-Fa-f0-9]+)|(0[0-7]*))(((u|U)(l|L)?)|((l|L|LL|ll)(u|U)?))?"

hex_float_constant:
    "0(x|X)((([A-Fa-f0-9]*\.[A-Fa-f0-9]+)|([A-Fa-f0-9]+\.))|([A-Fa-f0-9]+))p(\+|-)?\d+(f|l|F|L)?"

decimal_float_constant:
    "((((\d*\.\d+)|(\d+\.))([eE][-+]?\d+)?)|(\d+[eE][-+]?\d+))(f|l|F|L)?"

float_constant:
    decimal_float_constant | hex_float_constant

enum_constant(cxpeggen.check_enum):
    identifier

char_constant:
    "[LuU]?'([^\\\\]*?(\\\\.)?)*?'"

constant:
    int_constant | float_constant | enum_constant | char_constant

// check to make sure the inner double quotes work
string_literal:
    "(u8|u|U|L)?\"([^\\\\]*?(\\\\.)?)*?\""  // better one from my json grammar might be "(u8|u|U|L)?\"(((?<=\\\\)\")|[^\"])*\"" // this is literally everything between two double quotes including escaped double quotes

// below are for parsing

primary_expression:
	  identifier
	| constant
	| string_literal
	| '(', expression, ')'
	| generic_selection
	
generic_association:
	(type_name | 'default'), ':', assignment_expression

generic_assoc_list:
	','.generic_association
	
generic_selection:
	'_Generic', '(', assignment_expression, ',', generic_assoc_list, ')'
	
closed_initializer_list:
	'{', initializer_list, ','?, '}' // forward declare initializer_list?
	
initializer_list:
	','.(designation?, initializer)
	
initializer:
	assignment_expression | closed_initializer_list
	
compound_literal:
	'(', type_name, ')', closed_initializer_list
	
parameterized_access_expr:
	'[', expression, ']'
	
// arrays, [] operator overloading, and templates
get_member_expression:
	parameterized_access_expr, !'=' 

set_member_expression:
	parameterized_access_expr , '=', initializer

// must disambiguate or handle assigment vs keyword setting	
argument_expression_list:
	','.assignment_expression

call_expression:
	'(', argument_expression_list?, ')'
	
namespace_access_expression:
	'.', identifier // namespace, struct, or union member access
	
pointer_access_expression:
	'->', identifier	// struct or union pointer member access

postfix_expression_start:
    primary_expression | compound_literal // compound_literal in C23 only

// fix left recursion
postfix_expression:
	postfix_expression_start, ( get_member_expression
                              | set_member_expression
                              | call_expression
                              | namespace_access_expression
                              | pointer_access_expression
                              | '++'
                              | '--'
                              )*
	
unary_operator:
	  '&'
	| '*'
	| '+'
	| '-'
	| '~'
	| '!'
	
cast_expression:
	('(', type_name, ')')*, unary_expression
	
// unary_expression is a good test of PEG operator precedence
unary_expression:
	  postfix_expression
	| '++', unary_expression
	| '--', unary_expression
	| unary_operator, cast_expression
	| 'sizeof', '(', (cast_expression | type_name), ')'
	| ('_Alignof' | 'alignof'), '(', type_name, ')'
	| ('typeof' | 'typeof_unqual'), '(', (expression | type_name), ')'

// this was originally here, but should not be. It should probably be a primary expression	
/* | 'super', '(', type_name, (',', (identifier | template_instance))?, ')' */ // not sure about this one
	
multiplicative_expression:
	cast_expression, (('*' | '/' | '%'), cast_expression)*
	
additive_expression:
	multiplicative_expression, (('+' | '-'), multiplicative_expression)*
	
shift_expression:
	additive_expression, (('<<' | '>>'), additive_expression)*
	
relational_expression:
	shift_expression, (('<' | '>' | '<=' | '>='), shift_expression)*
	
equality_expression:
	relational_expression, (('==' | '!='), relational_expression)*
	
AND_expression:
	equality_expression, ('&', equality_expression)*
	
XOR_expression:
	AND_expression, ('^', AND_expression)*
	
OR_expression:
	XOR_expression, ('|', XOR_expression)*

logAND_expression:
	OR_expression, ('&&', OR_expression)*

logOR_expression:
	logAND_expression, ('||', logAND_expression)*
	
conditional_expression:
	logOR_expression, ('?', expression, ':', logOR_expression)*

assignment_operator:
	  '='
	| '*='
	| '/='
	| '%='
	| '+='
	| '-='
	| '<<='
	| '>>='
	| '&='
	| '^='
	| '|='

assignment_expression:
	(unary_expression, assignment_operator)*, conditional_expression
	
expression:
	','.assignment_expression
	
constant_expression:
	conditional_expression
	
// DECLARATIONS

storage_class_specifier:
	  'auto' // C11
	| 'constexpr' // C23
	| 'extern'
	| 'register'
	| 'static'
	| '_Thread_local' // pre-C23
	| 'thread_local' // C23
	| 'typedef'
	
type_specifier:
	  'void'
	| 'char'
	| 'short'
	| 'int'
	| 'long'
	| 'float'
	| 'double'
	| 'signed'
	| 'unsigned'
	| '_BitInt', '(', constant_expression, ')' // C23
	| '_Bool' // pre-C23
	| 'bool' // C23
	| '_Complex'
	| atomic_type_specifier
	| struct_or_union_specifier
	| enum_specifier
	| typedef_name
	
type_qualifier:
	  'const'
	| 'volatile'
	| 'restrict'
	| '_Atomic'
	
atomic_type_specifier:
	'_Atomic', '(', type_name, ')'
	
specifier_qualifier_list:
	(type_specifier | type_qualifier)+ // restrict so that 'const' may not be first
	
function_specifier:
	'inline' | '_Noreturn'
	
alignment_specifier:
	('_Alignas' | 'alignas'), '(', (type_name | constant_expression), ')'
	
declaration_specifiers:
	storage_class_specifier?, function_specifier?, (specifier_qualifier_list, alignment_specifier?)+
	
pointer:
	('*', type_qualifier*)+

parameter_declaration:
	declaration_specifiers, (declarator | abstract_declarator)? // need to forward declare declarator and abstract declarator
	
parameter_list:
	','.parameter_declaration
	
parameter_type_list:
	parameter_list, (',', '...')?
	
identifier_list:
	','.identifier
	
type_name:
	specifier_qualifier_list, abstract_declarator? // forward declare abstract declarator
	
declarator:
	pointer?, direct_declarator // forward declare direct_declarator
	
array_declarator: // VLAs are EXCLUDED!
	'[', 'static'?, type_qualifier_list?, assignment_expression, ']'

function_declarator:
	'(', (parameter_type_list | identifier_list)?, ')' // consider excluding the identifier_list
	
direct_declarator: 
	(identifier | '(', declarator, ')'), (array_declarator | function_declarator)*
	
abstract_declarator:
	  pointer
	| pointer?, direct_abstract_declarator // forward declare direct_abstract_declarator
	
direct_abstract_declarator:
	  '(', abstract_declarator, ')'
	| ('(', abstract_declarator, ')')?, (array_declarator | function_declarator)+
	
typedef_name(cxpeggen.check_typedef_name):
	identifier
	
designator:
	  '[', constant_expression, ']'
	| '.', identifier
	
designator_list:
	designator+

designation:
	designator_list, '='
	
static_assert_declaration:
	'_Static_assert', '(', constant_expression, ',', string_literal, ')', ';'
	
init_declarator:
	declarator, ('=', initializer)?
	
init_declarator_list:
	','.init_declarator
	
declaration:
	  declaration_specifiers, init_declarator_list?, ';'
	| static_assert_declaration
enumerator:
	enum_constant, ('=', constant_expression)?

enumerator_list:
	','.enumerator
	
closed_enumerator_list:
	'{', enumerator_list, ','?, '}'

enum_specifier:
	'enum', ((identifier?, enumerator_list) | identifier)
	
struct_declarator:
	  declarator
	| declarator?, ':', constant_expression
	
struct_declarator_list:
	','.struct_declarator
	
struct_declaration:
	  specifier_qualifier_list, struct_declarator_list?, ';'
	| static_assert_declaration
	
struct_or_union:
	'struct' | 'union'
	
struct_or_union_specifier:
	struct_or_union, ((identifier?, '{', struct_declaration+, '}') | identifier)
	
// STATEMENTS

labeled_statement:
	(identifier | ('case', constant_expression) | 'default'), ':', statement
	
block_item:
	declaration	| statement
	
block_item_list:
	block_item+
	
compound_statement:
	'{', block_item_list?, '}'
	
expression_statement:
	expression?, ';'
	
selection_statement:
	  'if', '(', expression, ')', (statement, 'else')?, statement
	| 'switch', '(', expression, ')', statement
	
iteration_statement:
	  'while', '(', expression, ')', statement
	| 'do', statement, 'while', '(', expression, ')', ';'
	| 'for', '(', (expression?, ';' | declaration), expression?, ';', expression?, ')', statement

jump_statement:
	(('goto', identifier) | 'continue' | 'break' | ('return', expression?)), ';'

statement:
	  labeled_statement
	| compound_statement
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	
// function_specifier for functions only
template_attribute:
	(postfix_expression	| 'extern' | 'static' | function_specifier ), !'['
	
template_attribute_list:
	template_attribute*

non_brkt:
	"[^\[]]*"*
	
brkt_block:
	'[', non_brkt, brkt_block?, non_brkt, ']'
	
non_paren:
	"[^\()]*"*
	
paren_block:
	'(', non_paren, paren_block?, non_paren, ')'
	
non_brace:
	"[^\{}]*"*
	
brace_block:
	'{', non_brace, brace_block?, non_brace, '}'
	
template_type:
	  'callable'
	| 'struct'
	| 'union'
	| 'enum'
	| 'macro'
	
template_parameter_list:
	','.identifier
	
template_definition:
	template_type, template_attribute_list, identifier , ('[', template_parameter_list?, ']')?, paren_block?, brace_block, ';'
	
template_argument:
	type_name	| constant_expression
	
template_argument_list:
	','.template_argument
	
template_instance:
	identifier, ('[', template_argument_list, ']')?
	
// REMOVE declaration_list? for old-style K&R
function_definition:
	declaration_specifiers, declarator, declaration_list?, compound_statement
	
external_declaration:
	  template_definition
	| function_definition
	| declaration

